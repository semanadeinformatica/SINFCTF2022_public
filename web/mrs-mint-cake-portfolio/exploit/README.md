# Mrs. Mint Cake Portfolio

## Recon

On the description of the challenge, we see that there is a login page and that we shouldn't go there. We'll definitely go there.

By going to the website, we immediately see a few important things.
The website's favicon is the same as [MongoDB's](https://www.mongodb.com/).
This indicates that the challenge has something to do with MongoDB.

If we inspect the source code of the portfolio page, we see a hidden dialog element. 
It contains a message from Mrs. Mint Cake to "admin".

On the login page, we see a login form.
If we try username = "admin" and password = "admin", we get an error: `Invalid username and/or password!`.
No dice...

Let's see what requests our browser is doing.
We can see that it is doing a POST request to the route `/api/login`, with the following payload

```json
{
    "username": "admin",
    "password":"admin"
}
```

Let's try a few different payloads and see what kind of errors we can get. For this, we can use Postman or Insomnia or any other HTTP client.

If we try

```json
{}
```

we get a different error! It says "Invalid username!", weird...

Let's try to put a random username, such as "test".

```json
{
    "username": "test"
}
```

We get "Invalid username and/or password!".
If we use "admin" instead of test, like so

```json
{
	"username": "admin"
}
```

we get a different error! It states "Invalid password!".

This is all very weird behavior with no clear pattern, but if we look closely, we can see these as queries to a database.
If we specify the username and password, the API will look for a user with that username and password, which is why it said "Invalid password and/or username!" when we look for username = "admin" and password = "admin". It didn't find any user with that username and password or, putting it another way, the admin's password is not "admin". We can confirm this on our last payload, since just specifying the username found a user, but, as expected, the passwords did not match.

We can deduce that our payload is being directly passed on to the database, which leaves this endpoint vulnerable to NoSQL injection.
We can confirm this by submitting the following payload

```json
{
    "username": "admin",
    "password": {
        "$regex": "^.*$"
    }
}
```

The error we get this time is "Invalid password!" meaning that a user was found, but the passwords did not match.
We can exploit this to find out the admin's password. First of all, we need to find what kind of characters are in the admin's password.

The following regexes are some of the steps I took to do just that.

`"[a-z]"` - this confirms whether or not the password contains any of these characters (yes)
`"^[a-z]*$"` - this confirms whether or not the password is made *only* with these characters (no)

We can repeat the process of adding more and more characters until we know all of the characters that the admin's password is made out of.

`"[A-Z]"` - contains these characters
`"^[a-zA-Z]*$"` - there are still missing characters

`"[0-9]"` - contains these characters
`"^[a-zA-Z0-9]*$"` - there are still missing characters

`"[{}[\\]()!@#$%^&*]"` - contains these characters
`"^[a-zA-Z0-9{}[\\]()!@#$%^&*]*$"` - there are no missing characters

So, the password is made up of the following characters

`0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ{}[]()!@#$%^&*`

Jeez... Our next task is to find out how many characters the admin's password has. To do that we can use regexes such as `"^.{3,5}`$"` to find out if it's made up of 3 to 5 characters, for instance.

`"^.{0,10}$"` - no
`"^.{0,100}$"` - yes
`"^.{0,50}$"` - yes
`"^.{20,50}$"` - yes
`"^.{30,50}$"` - yes
`"^.{30,40}$"` - yes
`"^.{30,35}$"` - yes
`"^.{32,35}$"` - yes
`"^.{32}$"` - yes, the password is made up of 32 characters

## The exploit

Knowing the information above, we can create a script that, for each character, finds out if it's a lowercase letter, an uppercase letter, a number or a symbol and then does a search to find out the exact character.

As such, we've written the `recoverpw.py` script to extract and derive the password from the website's responses.

> Flag: `SINFCTF2022{n0sQl_1nj3ct10n_1s_s0_mInT_bl0w1ng}`
