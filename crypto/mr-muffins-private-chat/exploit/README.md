# Mr. Muffin's Private Chat

## Recon

When we `nc` to the server, we see a menu that lets us create a new account on the server or log in to an existing one.
We also see that the server is running on Java 17.0.2.

If we create an account, we can choose any username, except "admin" or "system", which are already taken (the system account is not important for the challenge, though).
Submitting the username "test" we get an ECDSA signature, encoded in base64, that we must keep to log in with that account again.

> For instance, it could be `9iyZVW9Fos+9+2LuhDkhnFKLNqLSUYzXlU9wM1kpudoTg1bEBYEEuRX0DAoBdgCUBiiGHHd/uAoHSzRru4ZI+w==`
>
> Note: if we restart the container, we can see that the ECDSA signature changes, which in turn means that the keys being used are randomly generated (most likely)

If we log in again with the username and ECDSA signature provided, we can see 3 options: read incoming messages, send messages or exit.
If we go to check out our incoming messages, *nothing*, no flag. Let's keep looking.

If we send a message, we can choose the username of the person we want to send the message to and the content of the message.
If we send it to ourselves, we can see that, now, we do have a pending message, which is as follows:

`[03/11/2022, 15:05:33] @test: hallooooooo`

So, we can see that the option to send messages works.

If we exit and try to log in again, but provide a random base64 string, we will most likely get an error with the following message:

```
| Connection terminated.
| Reason: ECDSA signature must be 64 bytes long
```

---

In short, we found out that:

- the server uses Java 17.0.2
- it uses 64-byte ECDSA signatures, encoded in base64, for login
- there is already an "admin" user
- we can send messages to any user
- we can read the messages that have been sent to the user we are currently logged in as


## The exploit

If we go on the internet and search for "Java 17.0.2 ECDSA", some of the links talk about a CVE.
It's CVE-2022-21449, also known as Psychic Signatures. The exploit is due to a faulty implementation in Java's ECDSA signature verification.

Java doesn't check for the special case for which a signature is **always** valid - when its parameters, r and s, are both 0. 
Proper implementations should check that both r and s are >= 1, but this was not taken into account in Java's implementation.
As a result, we can provide r = 0 and s = 0 and, in theory, we should be able to log in with any account.

There are many formats for ECDSA signatures in Java, but if we just try submitting 64 null bytes, encoded as a base64 string, it will work.

The "master" key: `AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==`

If we log in to the "admin" account with that key, we'll be able to read their messages and get the flag.

> Flag: `SINFCTF2022{th3_L0nG3r_ThE_b3TTeR}`
